using AoCHelper;

namespace AdventOfCode
{
    public class Day_03 : BaseDay
    {
        private readonly List<string> _diagnosticReport;

        public Day_03()
        {
            _diagnosticReport = File.ReadAllLines(InputFilePath).ToList();
            CalculateLifeSupportRating(_diagnosticReport);
        }

        public override ValueTask<string> Solve_1() => new(CalculatePowerConsumption(_diagnosticReport).ToString());

        public override ValueTask<string> Solve_2() => new(CalculateLifeSupportRating(_diagnosticReport).ToString());

        private long CalculatePowerConsumption(List<string> diagnosticReport)
        {
            var (gammaRate, epsilonRate) = CalculateGammaAndEpsilonRate(diagnosticReport);
            return gammaRate * epsilonRate;
        }

        private (long gammaRate, long epsilonRate) CalculateGammaAndEpsilonRate(List<string> diagnosticReport)
        {
            var convertedDiagnosticReport = ConvertDiagnosticReport(diagnosticReport);

            var gammaRateString = string.Empty;
            var epsilonRateString = string.Empty;

            foreach (var line in convertedDiagnosticReport)
            {
                var isBit0MostCommon = line.Count(bit => bit == '0') > (line.Length / 2);
                gammaRateString += isBit0MostCommon ? "0" : "1";
                epsilonRateString += isBit0MostCommon ? "1" : "0";
            }

            return (ConvertBitStringToLong(gammaRateString), ConvertBitStringToLong(epsilonRateString));
        }

        private long CalculateLifeSupportRating(List<string> diagnosticReport)
        {
            var oxygenGeneratorRating = CalculateRating(diagnosticReport.ToList(), true);
            var co2ScrubberRating = CalculateRating(diagnosticReport.ToList(), false);

            return oxygenGeneratorRating * co2ScrubberRating;
        }

        private long CalculateRating(List<string> diagnosticReport, bool keepMostBits)
        {
            var oxygenGeneratorRating = diagnosticReport.ToList();

            for (var i = 0; i < diagnosticReport[0].Length; i++)
            {
                if(oxygenGeneratorRating.Count == 1)
                {
                    break;
                }

                var allBitsOnPosition = GetAllBitsOnPosition(oxygenGeneratorRating, i);
                oxygenGeneratorRating = CountBits(allBitsOnPosition) switch
                {
                    BitCountResult.MoreBit0 => oxygenGeneratorRating.Where(line => line[i] == (keepMostBits ? '0' : '1')).ToList(),
                    BitCountResult.MoreBit1 or BitCountResult.Equal => oxygenGeneratorRating.Where(line => line[i] == (keepMostBits ? '1' : '0')).ToList(),
                    _ => throw new NotImplementedException()
                };
            }

            return ConvertBitStringToLong(oxygenGeneratorRating.First());
        }

        private BitCountResult CountBits(string line)
        {
            var countBit0 = 0;
            var countBit1 = 0;

            for(var i = 0; i < line.Length; i++)
            {
                if(line[i] == '0')
                {
                    countBit0++;
                }
                else
                {
                    countBit1++;
                }
            }

            if(countBit0 == countBit1)
            {
                return BitCountResult.Equal;
            }

            return countBit0 > countBit1 ? BitCountResult.MoreBit0 : BitCountResult.MoreBit1;
        }

        /// <summary>
        /// Convert the report so that a new list of strings is generated by using the values of each diagnosticreport item on the same position
        /// (e.g. all values on index 0 create a new string, all values on index 1 create a new string, ...)
        /// </summary>
        /// <param name="diagnosticReport"></param>
        /// <returns></returns>
        private IEnumerable<string> ConvertDiagnosticReport(List<string> diagnosticReport)
        {
            for(var i = 0; i < diagnosticReport[0].Length; i++)
            {
                yield return GetAllBitsOnPosition(diagnosticReport, i);
            }
        }

        private long ConvertBitStringToLong(string bitString) => Convert.ToInt64(bitString, 2);

        private string GetAllBitsOnPosition(List<string> diagnosticReport, int position)
            => string.Join("", diagnosticReport.Select(line => line[position]));

        private enum BitCountResult
        {
            Equal,
            MoreBit0,
            MoreBit1
        }
    }
}
